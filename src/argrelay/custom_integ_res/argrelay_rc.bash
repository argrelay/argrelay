#!/usr/bin/env bash
# `argrelay` integration file: https://github.com/uvsmtid/argrelay

# This script is source-able by `~/.bashrc`:
#     source path/to/argrelay_rc.bash

# The main purposes of this script:
# *   enable auto-completion for the commands
# *   add commands to PATH

# Normally, this script is a symlink to orig artifact from `argrelay` distrib package.
# The path where this symlink (or copy) is located is supposed to contain:
# *   `run_argrelay_client` artifact (generated by `generate_artifacts.bash`)
# *   `argrelay_rc_conf.bash` defining `argrelay_bind_commands` env var
# When it is sourced, it re-creates symlinks for all command names listed in `argrelay_rc_conf.bash`
# (in `argrelay_bind_commands` env var) into `run_argrelay_client`.
# Then `argrelay` auto-completion is enabled for all of them.
# When sourced in `~/.bashrc`, this config becomes available in any new Bash instance.

# Note that enabling exit on error (like `set -e` below) will exit parent Bash shell (as this one is sourced).
# Use these options with care as it prevents starting any shell in case of errors.

# Debug: Print commands before execution:
#set -x
# Debug: Print commands after reading from a script:
#set -v
# Return non-zero exit code from commands within a pipeline:
#set -o pipefail
# Exit on non-zero exit code from a command:
#set -e
# Inherit trap on ERR by sub-shells:
#set -E
# Error on undefined variables:
#set -u

# The dir of the script:
script_dir="$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
# It is expected that `argrelay_rc.bash` is located within target project dir.
# Do not switch to the `script_dir`.

# Test files generated by `generate_artifacts.bash` script:
test -f "${script_dir}/run_argrelay_server" || return 1
test -f "${script_dir}/run_argrelay_client" || return 1

if [[ ! -f "${script_dir}/argrelay_rc_conf.bash" ]]
then
    echo "ERROR: \`${script_dir}/argrelay_rc_conf.bash\` does not exists" 1>&2
    echo "It is required to know which command names will have \`argrelay\` auto-completion." 1>&2
    echo "Provide \`${script_dir}/argrelay_rc_conf.bash\`, for example (copy and paste and modify):" 1>&2
    echo "" 1>&2
    # TODO: Why not to consolidate all commit-able `*_conf.bash` files into one?
    cat << 'argelay_rc_conf_EOF'
########################################################################################################################
# `argrelay` integration file: https://github.com/uvsmtid/argrelay
# This config file is supposed to be owned and version-controlled by target project integrated with `argrelay`.

# Bash array of command names (names of symlinks to `run_argrelay_client`):
argrelay_bind_commands=(
    relay_demo
    some_command
)
########################################################################################################################
argelay_rc_conf_EOF
    return 1
fi

# Load user config for env vars:
# *   argrelay_bind_commands
source "${script_dir}"/argrelay_rc_conf.bash

# shellcheck disable=SC2154
if [[ "${#argrelay_bind_commands[@]}" -lt 1 ]]
then
    # At least one command should be listed in `argrelay_bind_commands`:
    return 1
fi

export ARGRELAY_CLIENT_COMMAND="${argrelay_bind_commands[0]}"

for argrelay_command_name in "${argrelay_bind_commands[@]}"
do
    # When `run_argrelay_client` is executed,
    # its actual command name (`${argrelay_command_name}`) is sent as the first arg (args[0])
    # which `argrelay` framework can use to look up and run any custom command line interpreter.

    # Symlink `${argrelay_command_name}` command to `run_argrelay_client`:
    if [[ -e "${script_dir}/${argrelay_command_name}" ]]
    then
        if [[ -L "${script_dir}/${argrelay_command_name}" ]]
        then
            if [[ "$( readlink "${script_dir}/${argrelay_command_name}" )" != "run_argrelay_client" ]]
            then
                echo "WARN: symlink does not point to \`run_argrelay_client\`: ${script_dir}/${argrelay_command_name}"
            fi
        else
            echo "WARN: symlink creation is obstructed by the path: ${script_dir}/${argrelay_command_name}"
        fi
    else
        ln -sn run_argrelay_client "${script_dir}/${argrelay_command_name}"
    fi

    # Command line auto-completion process is largely similar to parsing command line args.
    # The difference is only in last step - either/or:
    # (A) an action is run             (based on provided parsed arg values)
    # (B) arg values are suggested     (based on provided parsed arg values)
    # Therefore, the same `run_argrelay_client` can run both processes:
    # (A) as target command of `${argrelay_command_name}` symlink (above)
    # (B) as `-C` argument to Bash `complete` to configure auto-completion for `${argrelay_command_name}` (below)
    # Enable auto-completion for `${argrelay_command_name}` command:
    if [[ "${BASH_VERSION}" == 5* ]]
    then
        complete -o nosort -C run_argrelay_client "${argrelay_command_name}"
    else
        # Old Bash versions do not support `nosort` option:
        complete           -C run_argrelay_client "${argrelay_command_name}"
    fi
done

# Invoke completion programmatically:
function invoke_completion {
    # This function can be turned into generic one to invoke any
    # registered completion in Bash, but it is not straightforward, see:
    # https://brbsix.github.io/2015/11/29/accessing-tab-completion-programmatically-in-bash/
    # Instead, at least, invoke the same completion command starting `run_argrelay_client`:
    (
        export COMP_LINE="${READLINE_LINE}"
        export COMP_POINT="${READLINE_POINT}"
        # CompType.DescribeArgs = ASCII '^':
        export COMP_TYPE="94"
        # NOTE: Not useful: for any key sequence, it is only set to the last key (no use case at the moment).
        export COMP_KEY="88"

        run_argrelay_client
    )
}

# Bind Alt+Shift+Q to `invoke_completion` function.
bind -x '"\eQ":"invoke_completion"'
# See limitation of `bind -x` (which might only be a limitation of older Bash versions):
# https://stackoverflow.com/a/4201274/441652

# Add dir with `${argrelay_bind_commands}` into PATH to make them available in Bash as plain `basename`:
PATH="${script_dir}:${PATH}"
export PATH

# TODO: Figure out how to save these settings on start and enter on exit.
# Disable exit on errors and any extra debug info for interactive shell
# (see enabling them for the duration of this script above):
#set +u
#set +E
#set +e
#set +o pipefail
#set +v
#set +x
